#!/usr/bin/env python
# ----------------------------------------------------------------------------
# Copyright 2016-2017 ARM Ltd.
#  
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#  
#     http://www.apache.org/licenses/LICENSE-2.0
#  
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------

import argparse
import logging
import string
import subprocess
import sys
import time
import xml.etree.cElementTree as ElementTree
from io import BytesIO
from threading import Thread


logger = logging.getLogger('junit-wrapper')


class TeeBytesIO(BytesIO):
    """duplicate each write command to an additional file object"""
    def __init__(self, tee_fh):
        self.tee_fh = tee_fh
        super(TeeBytesIO, self).__init__()

    def write(self, s):
        self.tee_fh.write(s)
        BytesIO.write(self, s)


def get_parser():
    parser = argparse.ArgumentParser(description='JUNIT wrapper')

    parser.add_argument(
        '-o',
        '--output-file',
        metavar='FILE',
        type=argparse.FileType('w'),
        help='output JUNIT XML file name',
        required=True
    )

    parser.add_argument(
        '-s',
        '--test-suite',
        metavar='NAME',
        help='test suite name',
        required=True
    )

    parser.add_argument(
        '-t',
        '--test-case',
        metavar='NAME',
        help='test case name',
        required=True
    )

    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='verbose - duplicate command output to STDOUT'
    )

    parser.add_argument(
        '--validate',
        action='store_true',
        help='validate generated XML against Jenkins XSD. Requires "requests" and "lxml" libraries'
    )

    parser.add_argument(
        '-c',
        '--command',
        nargs=argparse.REMAINDER,
        help='command to be executed',
    )
    return parser


def get_file_copy_worker(infile, outfile):
    def do_work(_infile, _outfile):
        for line in iter(_infile.readline, ''):
            _outfile.write(line)
        _infile.close()
    thread = Thread(target=do_work, args=(infile, outfile))
    thread.daemon = True
    thread.start()
    return thread


def generate_junit_xml(test_suite, test_case, out_fh, stdout, stderr, return_code, duration_in_sec, command):
    test_suite_root_element = ElementTree.Element(
        'testsuite',
        tests='1',
        name=test_suite.replace(' ', '_'),
        failures=str(1 if return_code != 0 else 0),
        time=str(duration_in_sec)
    )
    test_case_element = ElementTree.SubElement(
        test_suite_root_element,
        'testcase',
        time=str(duration_in_sec),
        name=test_case.replace(' ', '_')
    )
    ElementTree.SubElement(test_case_element, 'system-out').text = filter(
        lambda x: x in string.printable, stdout.getvalue()
    )
    ElementTree.SubElement(test_case_element, 'system-err').text = filter(
        lambda x: x in string.printable, stderr.getvalue()
    )

    if return_code != 0:
        failure_msg = 'Command "{cmd}" returned {ret}'.format(cmd=' '.join(command), ret=return_code)
        ElementTree.SubElement(
            test_case_element,
            'failure',
            type='Non-Zero return code',
            message=failure_msg)

    ElementTree.ElementTree(test_suite_root_element).write(out_fh)

	
def do_validate(output_file):
    """
    useful when developing/maintaining the script
    perform XSD validation against Jenkins Junit plugin schema file
    :param output_file: output file generated by the script
    """

    from lxml import etree as lxml_etree
    import requests

    assert os.path.exists(output_file)
    logging.getLogger('requests').setLevel(logging.ERROR)

    jenkins_junit_xsd = 'https://raw.githubusercontent.com/jenkinsci/xunit-plugin/master/src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd'
    response = requests.get(jenkins_junit_xsd)
    response.raise_for_status()

    xmlschema_doc = lxml_etree.fromstring(response.content)
    xmlschema = lxml_etree.XMLSchema(xmlschema_doc)

    xml_doc = lxml_etree.parse(output_file)
    xmlschema.assertValid(xml_doc)


def main():
    parser = get_parser()
    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.verbose else logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )

    stdout = TeeBytesIO(sys.stdout) if args.verbose else BytesIO()
    stderr = TeeBytesIO(stdout)
    logger.debug('Executing "%s"', ' '.join(args.command))
    start_time = time.time()
    process = subprocess.Popen(args.command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    threads = [
        get_file_copy_worker(process.stdout, stdout),
        get_file_copy_worker(process.stderr, stderr)
    ]
    for t in threads:  # wait for IO completion
        t.join()
    return_code = process.wait()
    logger.debug('Wrapped process return code ' + str(return_code))
    duration_in_sec = time.time() - start_time

    with args.output_file as fh:  # insure file object is closed - since it will be read in do_validate()
        generate_junit_xml(
            args.test_suite,
            args.test_case,
            fh,
            stdout,
            stderr,
            return_code,
            duration_in_sec,
            args.command
        )
    logger.debug('Generated JUNIT report file ' + args.output_file.name)

    if args.validate:
        do_validate(args.output_file.name)

    raise SystemExit(return_code)

if __name__ == '__main__':
    main()
